<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Animacja 2</title>
  <meta name="description" content="Animacja 2">
  <meta name="author" content="Pawel Wozniak, 224868">

</head>

<body>
	<canvas id="canvas" width="800" height="600"></canvas>
  
	<script>
	  var canvas = document.getElementById('canvas');
	  var context = canvas.getContext('2d');

	  class Point {
		  constructor(x, y) {
			this.x = x;
			this.y = y;
		  }

		 rotatePoint(center, angle) {
			var s = Math.sin(Math.PI * angle/180);
			var c = Math.cos(Math.PI * angle/180);

			let tempPoint = new Point(this.x - center.x , this.y - center.y);
			this.x = (tempPoint.x * c - tempPoint.y * s) + center.x;
			this.y = (tempPoint.x * s + tempPoint.y * c) + center.y; 
	 	}

	 	absDistance(p) {
		    return Math.abs(Math.hypot(this.x - p.x, this.y - p.y));
	 	}
	}
	  class Vector {
		constructor(vx, vy) {
			this.vx = vx;
			this.vy = vy;
		  }

		length() {
			return Math.abs(Math.sqrt(this.vx * this.vx + this.vy * this.vy));
	 	}		

	 	getNormalized() {
		    return new Vector(this.vx/this.length() , this.vy/this.length());
	 	}
		
		setLength(value) {
			this.vx = this.getNormalized().vx * value;
			this.vy = this.getNormalized().vy * value;
		}

		rotateTo(angle) {
			var s = Math.sin(Math.PI * angle/180);
			var c = Math.cos(Math.PI * angle/180);

			var vecLength = this.length();

			this.vx = vecLength * c;
			this.vy = vecLength * s; 			
		}

		getNegate() {
			return new Vector(-this.vx, -this.vy);
		}
		
	  }

	  var screenSizeX = 800;
	  var screenSizeY = 600;
	  var screenCenter = new Point(screenSizeX/2, screenSizeY/2);
	  var worldZoom = 1;
	  var worldRadius = Math.sqrt(screenCenter.x * screenCenter.x + screenCenter.y * screenCenter.y) * 2;

	  var carSizeX = 10;
	  var carSizeY = 15;
	  var carCenter = new Point(screenSizeX/2, screenSizeY/2+100);
	  var carMaxAccelerate = 6;

	  var roadMaxWidth = 400;
	  var roadMinWidth = 200;
	  var roadMaxAngle = 0;
	  var roadMinAngle = 180;


	  var points = 0;
	  var time = 6;
	  
	  var textStatus = "WEEIArace";
	  var textPointsBase = "Points: ";
	  var textTimeBase = "Time: ";
	  var textPoints = textPointsBase + points;
	  var textTime = textTimeBase + time;

	  var Keys = {
		space: false,
        left: false,
        right: false,
		up: false,
        down: false
      };

	  class GameObject {
		  constructor(point, vector, angle, type) {
			  this.point = point;
			  this.vector = vector;
			  this.angle = angle;
			  this.type = type;
		  }

		  draw() {
			context.beginPath();
			context.rect(this.point.x-2, this.point.y+2, 4, 4);
			context.fillStyle = "orange";
			context.fill();
			context.lineWidth = 3;
			context.strokeStyle = '#003300';
			context.stroke();
		  }

		  update() {
			  this.move();
			  this.draw();
		  }

		  move() {
			  this.point.x = this.point.x + this.vector.vx;
			  this.point.y = this.point.y + this.vector.vy;
		  }
	  }

	  class Car extends GameObject {
		  draw() {
			var vert1 = new Point(this.point.x-carSizeX, this.point.y-carSizeY);
			var vert2 = new Point(this.point.x-carSizeX, this.point.y+carSizeY);
			var vert3 = new Point(this.point.x+carSizeX, this.point.y+carSizeY);
			var vert4 = new Point(this.point.x+carSizeX, this.point.y-carSizeY);

			vert1.rotatePoint(this.point, this.angle);
			vert2.rotatePoint(this.point, this.angle);
			vert3.rotatePoint(this.point, this.angle);
			vert4.rotatePoint(this.point, this.angle);

			context.beginPath();
			context.moveTo(vert1.x, vert1.y);
			context.lineTo(vert2.x, vert2.y);
			context.lineTo(vert3.x, vert3.y);
			context.lineTo(vert4.x, vert4.y);
			context.closePath();
			context.stroke();
			context.fillStyle = "blue";
			context.fill();
			context.lineWidth = 2;
			context.strokeStyle = '#003300';
			context.stroke();
		  }

		  accelerate() {
			  var newLength = this.vector.length() + 0.1;
			  if(newLength > carMaxAccelerate) { 
				newLength = carMaxAccelerate; 
			  }
			  this.vector = new Vector(10,0);
			  this.vector.rotateTo(this.angle+90);
			  this.vector.setLength(newLength);
		  }

		  decelerate() {
			var newLength = this.vector.length() - 0.1;
			  if(newLength < 0) { 
				newLength = 0; 
			  }
			  this.vector = new Vector(10,0);
			  this.vector.rotateTo(this.angle+90);
			  this.vector.setLength(newLength);
		  }

		  rotateLeft() {
			this.angle = this.angle + 5;
			if (this.angle > 360) {this.angle = this.angle - 360;}
			if (this.angle <0) {this.angle = 360 + this.angle; }
			this.vector.rotateTo(this.angle+90);
		  }

		  rotateRight() {
			this.angle = this.angle - 5;
			if (this.angle > 360) {this.angle = this.angle - 360;}
			if (this.angle <0) {this.angle = 360 + this.angle; }
			this.vector.rotateTo(this.angle+90);
		  }
		  
	  }

	  class Obstacle extends GameObject {
		draw() {
			context.beginPath();
			context.rect(this.point.x-1, this.point.y+1, 3, 3);
			context.fillStyle = "red";
			context.fill();
			context.lineWidth = 2;
			context.strokeStyle = '#003300';
			context.stroke();
		  }
	  }

	  class Bonus extends GameObject {

	  }

	  class Road {
		constructor() {
			this.center  = new Array();
			this.left = new Array();
			this.right = new Array();
			this.last = new GameObject(new Point(0, 0), new Vector(0,0), 0 , "last");
			this.emiter = new Point(screenCenter.x, screenCenter.y-worldRadius+400);
			this.width = roadMaxWidth;
			this.angle = 90;
		}

		draw() {
			this.left.forEach(obj =>  {
				if(isVisible(obj.point)) {
					obj.draw();
				}
			});
			this.right.forEach(obj =>  {
				if(isVisible(obj.point)) {
					obj.draw();
				}
			});
			this.center.forEach(obj =>  {
				if(isVisible(obj.point)) {
					obj.draw();
				}
			});
		}

		tidy() {
			let tempObjects = new Array(); 
			this.left.forEach(obj =>  {
				if (worldRadius >= obj.point.absDistance(screenCenter)) {
					tempObjects.push(obj);
				}
			});
			this.left = tempObjects;

			tempObjects = new Array(); 
			this.right.forEach(obj =>  {
				if (worldRadius >= obj.point.absDistance(screenCenter)) {
					tempObjects.push(obj);
				}
			});
			this.right = tempObjects;

			tempObjects = new Array(); 
			this.center.forEach(obj =>  {
				if (worldRadius >= obj.point.absDistance(screenCenter)) {
					tempObjects.push(obj);
				}
			});
			this.center = tempObjects;
		 }

		emit() {			
			if(this.last.point.absDistance(this.emiter) > 30) {
				this.last = this.last = new GameObject(new Point(this.emiter.x, this.emiter.y), new Vector(0,0), 0 , "last");
				this.center.push(new GameObject(new Point(this.emiter.x, this.emiter.y), new Vector(0,0), 0 , "roadCenter"));
				
				let fakePoint = new Point(this.emiter.x + this.width/2, this.emiter.y);
				fakePoint.rotatePoint(this.emiter, this.angle+90);
				this.left.push(new GameObject(fakePoint, new Vector(0,0), 0 , "roadLeft"));
				
				fakePoint = new Point(this.emiter.x + this.width/2, this.emiter.y);
				fakePoint.rotatePoint(this.emiter, this.angle-90);
				this.right.push(new GameObject(fakePoint, new Vector(0,0), 0 , "roadRight"));
			}
		}
		update() {
			this.left.forEach(obj =>  {
				obj.vector = game.world.car.vector.getNegate();
				obj.update();
			});
			this.right.forEach(obj =>  {
				obj.vector = game.world.car.vector.getNegate();
				obj.update();
			});
			this.center.forEach(obj =>  {
				obj.vector = game.world.car.vector.getNegate();
				obj.update();
			});
			this.last.vector = game.world.car.vector.getNegate();
			this.last.update();
			this.moveEmiter();
		}

		moveEmiter() {
			this.angle = this.angle + 0.04;
			if(this.angle>180) {this.angle = 180;}
			let fakeEmiter = new Point(screenCenter.x-worldRadius+400, screenCenter.y);
			fakeEmiter.rotatePoint(screenCenter, this.angle);
			this.emiter = fakeEmiter;
		}

	  }

	  class World {
		 constructor() {
			 this.car = new Car(new Point(screenCenter.x,screenCenter.y+100), new Vector(0,0), 180, "car");
			 this.road = new Road();
			 this.gameObjects = new Array(); 
			 this.angle = 0;
		 	 this.zoom = worldZoom;

			  for (var step = 0; step < 300; step++) {
				let point1 = new Point(getRandomInt(-worldRadius, worldRadius) , getRandomInt(-worldRadius, worldRadius));
				let obstacle = new Obstacle(point1, new Vector(0,0), 0, "obstacle");
				this.gameObjects.push(obstacle);
			  }
		 }

		 draw() {
			this.gameObjects.forEach(obj =>  {
				if(isVisible(obj.point)) {
					obj.draw();
				}
			});
			this.car.draw();
			this.road.emit();
			this.road.draw();
		 }

		 update() {
			this.gameObjects.forEach(obj =>  {
				obj.vector = this.car.vector.getNegate();
				obj.update();
			});
			this.tidy();
			this.road.update();
			this.road.tidy();
			this.draw();
			this.checkKeys();
			this.checkCollision();
		 }

		 tidy() {
			let tempObjects = new Array(); 
			this.gameObjects.forEach(obj =>  {
				if (worldRadius >= obj.point.absDistance(screenCenter)) {
					tempObjects.push(obj);
				}
			});
			this.gameObjects = tempObjects;
		 }

		 checkCollision() {
			let tempObjects = new Array(); 
			this.gameObjects.forEach(obj =>  {
				if (10 <= obj.point.absDistance(this.car.point)) {
					tempObjects.push(obj);
				} else {
					if(obj.type == "obstacle") {points++;}
				}
			});
			this.gameObjects = tempObjects;
		 }

		 checkKeys() {
			if(Keys.left) {this.car.rotateLeft()}
			if(Keys.right) {this.car.rotateRight()}
			if(Keys.up) {this.car.accelerate();}
			if(Keys.down) {this.car.decelerate();}
		 }

	  }

	  class Game {
		  constructor() {
			  this.world = new World();
		  }
	  }

	  function mainLoop() {
		clearScreen();
		
		drawStage();

		game.world.update();

		drawStatusBar();
		// if(time===0) {gameOver();}
	 }
	 	 
	 function clearScreen() {
		context.clearRect( 0, 0 , screenSizeX, screenSizeY );
	 }
	

	 function isVisible(p) {
		 if(p.x>0 && p.x < screenSizeX && p.y>0 && p.y<screenSizeY) {
			 return true;
		 }		 
		return false;
	 }

	 function getRandomInt(min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
    	return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	 function drawStatusBar() {
		textPoints = textPointsBase + points;
	    textTime = textTimeBase + time;
		context.font = '24px serif';
		context.fillStyle = "black";
		var textSize = context.measureText(textStatus);
		context.fillText(textStatus,screenSizeX/2 - (context.measureText(textStatus)).width/2, 24);
		context.fillText(textPoints,screenSizeX-20- textSize.width, 24);
		context.fillText(textTime, 20, 24);
	}

	 function drawStage() {
		context.beginPath();
		context.rect(0, 0, screenSizeX, 32);

		context.rect(0, 0, screenSizeX, screenSizeY);
		context.lineWidth = 3;
		context.strokeStyle = '#003300';
		context.stroke();

		context.beginPath();
		context.fillStyle = "lightgreen";
		context.fillRect(3, 34, screenSizeX-6, screenSizeY-3-34);
		context.lineWidth = 1;
		context.strokeStyle = '#003300';
		context.stroke();
	}

	function timeLoop() {
		time= time - 1;
		textTime = textTimeBase + time;
	}

	function gameOver() {
		clearInterval(t1);
		clearInterval(t2);
		showResult();
	}

	function showResult() {
	  context.fillStyle = "white";
      context.fillRect(100,100, screenSizeX-200, screenSizeY-200);
      context.font = "70pt sans-serif";
	  var result = "Wynik: "+points;
      context.strokeText(result, screenSizeX/2 - (context.measureText(result)).width/2, 300);
	  context.font = "20pt sans-serif";
	  context.fillStyle = "black";
	  var text = "Press ENTER to try again";
	  context.fillText(text, screenSizeX/2 - (context.measureText(text)).width/2, 400);
	  context.stroke();
	  window.onkeyup = function(e) {
		var kc = e.keyCode;
		e.preventDefault();
		if (kc === 13) window.location.reload();
	};
	}
		 
	window.onkeyup = function(e) {
		var kc = e.keyCode;
		e.preventDefault();

		if (kc === 37) Keys.right = false;
		if (kc === 39) Keys.left = false;
		if (kc === 38) Keys.up = false;
		if (kc === 40) Keys.down = false;
		if (kc === 32) Keys.space = false;
	};
	window.onkeydown = function(e) {
		var kc = e.keyCode;
		e.preventDefault();

		if (kc === 37) Keys.right = true; 
		if (kc === 39) Keys.left = true;
		if (kc === 38) Keys.up = true;
		if (kc === 40) Keys.down = true;
		if (kc === 32) Keys.space = true;
	};

	let game = new Game();
	var t1=setInterval(mainLoop,20);
	var t2=setInterval(timeLoop,1000);
	  
	</script>
</body>

</body>
</html>
